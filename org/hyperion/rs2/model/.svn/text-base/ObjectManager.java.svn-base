package org.hyperion.rs2.model;

import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.List;
import java.util.LinkedList;

import org.hyperion.cache.Cache;
import org.hyperion.cache.InvalidCacheException;
import org.hyperion.cache.index.impl.MapIndex;
import org.hyperion.cache.index.impl.StandardIndex;
import org.hyperion.cache.map.LandscapeListener;
import org.hyperion.cache.map.LandscapeParser;
import org.hyperion.cache.obj.ObjectDefinitionListener;
import org.hyperion.cache.obj.ObjectDefinitionParser;

/**
 * Manages all of the in-game objects.
 * @author Graham Edgecombe
 *
 */
public class ObjectManager implements LandscapeListener, ObjectDefinitionListener {
	
	/**
	 * Logger instance.
	 */
	private static final Logger logger = Logger.getLogger(ObjectManager.class.getName());
	
	/**
	 * The number of definitions loaded.
	 */
	private int definitionCount = 0;
	
	/**
	 * The count of objects loaded.
	 */
	private int objectCount = 0;
	
	/**
	 * Loads the objects in the map.
	 * @throws IOException if an I/O error occurs.
	 * @throws InvalidCacheException if the cache is invalid.
	 */
	public void load() throws IOException, InvalidCacheException {
		Cache cache = new Cache(new File("./data/cache/"));
		try {
			/*OutputStream os = new FileOutputStream("data/worldmap.bin");
			buf = IoBuffer.allocate(1024);
			buf.setAutoExpand(true);*/
			//logger.info("Loading definitions...");
			StandardIndex[] defIndices = cache.getIndexTable().getObjectDefinitionIndices();
			new ObjectDefinitionParser(cache, defIndices, this).parse();
			//logger.info("Loaded " + definitionCount + " object definitions.");
			//logger.info("Loading map...");
			MapIndex[] mapIndices = cache.getIndexTable().getMapIndices();
			for(MapIndex index : mapIndices) {
				new LandscapeParser(cache, index.getIdentifier(), this).parse();
			}
			//logger.info("Loaded " + objectCount + " objects.");
			System.out.println("Loaded Object Definitions for " + objectCount + " objects.");
			
			/*buf.flip();
			byte[] data = new byte[buf.limit()];
			buf.get(data);
			os.write(data);
			os.flush();
			os.close();*/
		} finally {
			cache.close();
		}
	}
	/*private IoBuffer buf = null;*/

	@Override
	public void objectParsed(GameObject obj) {
		objectCount++;
		/*buf.putShort((short) obj.getDefinition().getId());
		buf.putShort((short) obj.getLocation().getX());
		buf.putShort((short) obj.getLocation().getY());
		buf.put((byte) obj.getLocation().getZ());
		buf.put((byte) obj.getType());
		buf.put((byte) obj.getRotation());*/
		World.getWorld().getRegionManager().getRegionByLocation(obj.getLocation()).getGameObjects().add(obj);
	}

	@Override
	public void objectDefinitionParsed(GameObjectDefinition def) {
		definitionCount++;
		GameObjectDefinition.addDefinition(def);
	}
	
	private List<GameObject> globalObjects = new LinkedList<GameObject>();
	
	public void addObject(GameObject obj){
		globalObjects.add(obj);
		update(obj);
	}
	
	public void removeObject(GameObject obj){
		globalObjects.remove(obj);
	}
	
	public void update(GameObject obj) {
		for(Player p : World.getWorld().getPlayers()){
			if(p.getLocation().isWithinDistance(obj.getLocation(),64))
				p.getActionSender().sendReplaceObject(obj.getLocation().getX(), obj.getLocation().getY(),obj.getDefinition().getId(),obj.getRotation(), obj.getType());
		}
	}

}
